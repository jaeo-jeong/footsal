<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>젓자FC 팀 짜기</title>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .section {
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 1.5em;
            color: #333;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }


        .players-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .player-card {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
            transition: all 0.3s;
        }

        .player-card:hover {
            border-color: #667eea;
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .player-name {
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 10px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .player-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .player-fields {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .field-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .field-group label {
            font-size: 0.9em;
            color: #666;
            font-weight: 500;
        }

        .field-group select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 0.95em;
        }

        .delete-btn {
            margin-top: 10px;
            padding: 6px 12px;
            font-size: 0.85em;
        }

        .add-player-form {
            background: #f8f9fa;
            border: 2px dashed #667eea;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .form-row {
            display: grid;
            grid-template-columns: 2fr 1fr auto;
            gap: 10px;
            align-items: end;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .form-group label {
            font-size: 0.9em;
            color: #666;
            font-weight: 500;
        }

        .form-group input,
        .form-group select {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1em;
        }

        .teams-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .team {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            padding: 20px;
            color: white;
        }

        .team-title {
            font-size: 1.5em;
            font-weight: 700;
            margin-bottom: 15px;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
        }

        .team-stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
            font-size: 0.9em;
            opacity: 0.9;
        }

        .team-players {
            list-style: none;
        }

        .team-player {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player-info {
            display: flex;
            flex-direction: column;
        }

        .player-tier {
            font-size: 0.85em;
            opacity: 0.9;
        }


        .tier-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 5px;
            font-size: 0.75em;
            font-weight: 600;
            margin-left: 5px;
        }

        .tier-S { background: #ff6b6b; }
        .tier-Aplus { background: #ffa500; }
        .tier-A { background: #ffd93d; }
        .tier-Bplus { background: #5dd68a; }
        .tier-B { background: #6bcf7f; }
        .tier-C { background: #4ecdc4; }
        .tier-D { background: #95a5a6; }

        .tier-table {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            border: 2px solid #e9ecef;
        }

        .tier-table-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            text-align: center;
        }

        .tier-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .tier-item {
            background: white;
            border-radius: 8px;
            border: 2px solid #e9ecef;
            padding: 15px;
        }

        .tier-item-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e9ecef;
        }

        .tier-item-label {
            font-size: 1.3em;
            font-weight: 700;
        }

        .tier-item-count {
            font-size: 0.9em;
            color: #666;
            margin-left: auto;
        }

        .tier-item-players {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .tier-player-name {
            padding: 5px 10px;
            background: #f8f9fa;
            border-radius: 5px;
            font-size: 0.9em;
            color: #333;
        }

        @media (max-width: 768px) {
            .form-row {
                grid-template-columns: 1fr;
            }

            .players-grid {
                grid-template-columns: 1fr;
            }
            
            .modal-content {
                padding: 20px;
                max-height: 85vh;
            }
            
            #voteModal .modal-content {
                max-height: 85vh;
            }
            
            .modal-title {
                font-size: 1.2em;
                margin-bottom: 15px;
            }
        }

        /* 모달 스타일 */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background-color: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            max-height: 90vh;
        }
        
        /* 투표 모달 전용 스타일 */
        #voteModal .modal-content {
            max-width: 600px;
            max-height: 90vh;
        }
        
        #voteContent {
            overflow-y: auto;
            overflow-x: hidden;
            flex: 1;
            min-height: 0;
            margin-bottom: 20px;
            padding-right: 10px;
            -webkit-overflow-scrolling: touch;
        }
        
        /* 모달 내부 스크롤 시 배경 스크롤 방지 */
        #voteModal .modal-content {
            touch-action: pan-y;
        }
        
        /* 스크롤바 스타일링 (선택사항) */
        #voteContent::-webkit-scrollbar {
            width: 8px;
        }
        
        #voteContent::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        
        #voteContent::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        
        #voteContent::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .modal-title {
            font-size: 1.5em;
            font-weight: 600;
            margin-bottom: 20px;
            text-align: center;
            color: #333;
        }

        .modal-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            margin-bottom: 15px;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-shrink: 0;
            margin-top: auto;
        }

        .vote-section {
            background: #f8f9fa;
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .vote-title {
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
        }

        .vote-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
        }

        .vote-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: white;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .vote-item select {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* 승/무/패 입력 박스 스타일 */
        .record-input {
            width: 50px;
            padding: 8px 5px;
            border: 1px solid #ddd;
            border-radius: 5px;
            text-align: center;
            font-size: 0.95em;
        }
        
        /* number input 스피너 제거 */
        .record-input::-webkit-inner-spin-button,
        .record-input::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        .record-input {
            -moz-appearance: textfield;
            appearance: textfield;
        }
    </style>
</head>
<body>
    <!-- 관리자 코드 입력 모달 -->
    <div id="adminModal" class="modal">
        <div class="modal-content">
            <div class="modal-title">관리자 코드 입력</div>
            <input type="password" id="adminCodeInput" class="modal-input" placeholder="관리자 코드를 입력하세요">
            <div class="modal-buttons">
                <button class="btn btn-primary" onclick="enterAsAdmin()">관리자로 입장</button>
                <button class="btn btn-secondary" onclick="enterAsGuest()">일반 사용자로 입장</button>
            </div>
        </div>
    </div>

    <div class="container">
        <h1>⚽ 젓자FC</h1>
        
        <div style="text-align: center; margin-bottom: 20px;">
            <button id="resetBtn" class="btn btn-secondary" onclick="resetToDefault()" style="background: #dc3545; color: white;" disabled>
                초기값으로 되돌리기
            </button>
            <button id="voteBtn" class="btn btn-primary" onclick="openVoteModal()" style="margin-left: 20px;">
                티어 투표하기
            </button>
            <button id="voteHistoryBtn" class="btn btn-info" onclick="openVoteHistoryModal()" style="margin-left: 20px; background: #17a2b8; color: white; display: none;">
                티어 투표 이력 보기
            </button>
        </div>

        <div class="tier-table">
            <div class="tier-table-title">티어 표</div>
            <div class="tier-list" id="tierList"></div>
        </div>

        <!-- 투표 모달 -->
        <div id="voteModal" class="modal">
            <div class="modal-content" style="max-width: 600px;">
                <div class="modal-title">티어 투표</div>
                <div id="voteContent"></div>
                <div class="modal-buttons">
                    <button class="btn btn-primary" onclick="submitVote()">투표 제출</button>
                    <button class="btn btn-secondary" onclick="closeVoteModal()">취소</button>
                </div>
            </div>
        </div>

        <!-- 투표 이력 모달 (관리자 전용) -->
        <div id="voteHistoryModal" class="modal">
            <div class="modal-content" style="max-width: 90%; max-height: 90vh;">
                <div class="modal-title">티어 투표 이력 (관리자 전용)</div>
                <div id="voteHistoryContent" style="overflow-y: auto; max-height: calc(90vh - 150px); padding: 20px;">
                    <div id="voteHistoryStats" style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                        <h3 style="margin: 0 0 10px 0; font-size: 1.2em;">투표 통계</h3>
                        <p style="margin: 5px 0; font-size: 1em;"><strong>총 투표 수:</strong> <span id="totalVoteCount">0</span>명</p>
                    </div>
                    <div id="voteHistoryTable"></div>
                </div>
                <div class="modal-buttons">
                    <button class="btn btn-secondary" onclick="closeVoteHistoryModal()">닫기</button>
                </div>
            </div>
        </div>

        <div class="section">
            <h2 class="section-title">선수 관리</h2>
            
            <div class="add-player-form" id="addPlayerForm" style="display: none;">
                <div class="form-row">
                    <div class="form-group">
                        <label>이름</label>
                        <input type="text" id="newPlayerName" placeholder="선수 이름">
                    </div>
                    <div class="form-group">
                        <label>티어</label>
                        <select id="newPlayerTier">
                            <option value="S">S</option>
                            <option value="A+">A+</option>
                            <option value="A">A</option>
                            <option value="B+">B+</option>
                            <option value="B" selected>B</option>
                            <option value="C">C</option>
                            <option value="D">D</option>
                        </select>
                    </div>
                    <button class="btn btn-success" onclick="addPlayer()">추가</button>
                </div>
            </div>

            <div class="players-grid" id="playersGrid"></div>
        </div>

        <div class="section">
            <h2 class="section-title">팀 구성</h2>
            <div class="controls">
                <button class="btn btn-secondary" onclick="selectAllPlayers()">전체 선택</button>
                <button class="btn btn-secondary" onclick="deselectAllPlayers()">전체 해제</button>
                <button class="btn btn-primary" onclick="generateFutsalTeams()">풋살팀 구성</button>
                <button class="btn btn-primary" onclick="generateSoccerTeams()">축구팀 구성</button>
                <label style="display: flex; align-items: center; gap: 8px; margin-left: 10px; cursor: pointer;">
                    <input type="checkbox" id="hideTierCheckbox" onchange="toggleTierVisibility()" style="width: 18px; height: 18px; cursor: pointer;">
                    <span style="font-size: 0.95em; color: #333;">티어 숨기기</span>
                </label>
            </div>
            <div class="teams-container" id="teamsContainer"></div>
        </div>
    </div>

    <!-- Firebase 설정 파일 -->
    <script src="firebase-config.js"></script>

    <script>
        // Firebase 초기화
        let db;
        let firebaseInitialized = false;
        
        function initializeFirebase() {
            try {
                console.log('Firebase 초기화 시도...');
                console.log('firebase 타입:', typeof firebase);
                console.log('firebaseConfig 타입:', typeof firebaseConfig);
                
                // Firebase SDK와 설정이 모두 로드되었는지 확인
                if (typeof firebase === 'undefined') {
                    console.error('❌ Firebase SDK가 로드되지 않았습니다.');
                    console.error('Firebase SDK 스크립트 태그를 확인해주세요.');
                    return false;
                }
                
                if (typeof firebaseConfig === 'undefined') {
                    console.error('❌ Firebase 설정이 없습니다. firebase-config.js 파일을 확인해주세요.');
                    return false;
                }
                
                console.log('✅ Firebase SDK와 설정 파일 로드 확인됨');
                console.log('firebaseConfig:', firebaseConfig);
                
                // 이미 초기화되었는지 확인
                if (firebase.apps && firebase.apps.length > 0) {
                    console.log('Firebase 이미 초기화됨, Firestore 연결 시도...');
                    try {
                        db = firebase.firestore();
                        // Firestore 연결 테스트
                        db.enablePersistence({ synchronizeTabs: true }).catch(err => {
                            console.warn('Firestore 오프라인 지속성 설정 실패:', err);
                        });
                        firebaseInitialized = true;
                        console.log('✅ Firebase 이미 초기화됨');
                        return true;
                    } catch (err) {
                        console.error('❌ Firestore 연결 실패:', err);
                        return false;
                    }
                }
                
                // Firebase 초기화
                console.log('Firebase App 초기화 시도...');
                const app = firebase.initializeApp(firebaseConfig);
                console.log('✅ Firebase App 초기화 완료');
                
                // Firestore 초기화
                console.log('Firestore 초기화 시도...');
                db = firebase.firestore();
                console.log('✅ Firestore 인스턴스 생성 완료');
                
                // Firestore 설정
                try {
                    db.settings({
                        cacheSizeBytes: firebase.firestore.CACHE_SIZE_UNLIMITED
                    });
                } catch (err) {
                    console.warn('Firestore 설정 실패 (무시 가능):', err);
                }
                
                // 간단한 연결 테스트 (비동기, 실패해도 계속 진행)
                console.log('Firestore 연결 테스트 시도...');
                const testRef = db.collection('_test').doc('connection');
                testRef.get().then(() => {
                    console.log('✅ Firestore 연결 테스트 성공');
                }).catch(err => {
                    console.error('❌ Firestore 연결 테스트 실패:', err);
                    console.error('오류 코드:', err.code);
                    console.error('오류 메시지:', err.message);
                    
                    // 일반적인 오류 코드별 안내
                    if (err.code === 'permission-denied') {
                        console.error('⚠️ 권한 거부: Firestore 보안 규칙을 확인해주세요.');
                        console.error('Firebase Console > Firestore Database > 규칙 탭에서 보안 규칙을 확인하세요.');
                    } else if (err.code === 'unavailable') {
                        console.error('⚠️ 서비스 사용 불가: Firestore Database가 생성되었는지 확인해주세요.');
                        console.error('Firebase Console > Firestore Database에서 데이터베이스를 생성하세요.');
                    } else if (err.code === 'failed-precondition') {
                        console.error('⚠️ 사전 조건 실패: Firestore Database가 활성화되지 않았을 수 있습니다.');
                    }
                });
                
                firebaseInitialized = true;
                console.log('✅ Firebase 초기화 완료!');
                console.log('db 상태:', db);
                return true;
            } catch (error) {
                console.error('❌ Firebase 초기화 실패:', error);
                console.error('오류 상세:', error.message);
                console.error('오류 스택:', error.stack);
                return false;
            }
        }
        
        // 페이지 로드 완료 후 Firebase 초기화
        function waitForFirebaseAndInit() {
            // Firebase SDK와 설정 파일이 로드될 때까지 대기
            let attempts = 0;
            const maxAttempts = 50; // 5초간 시도
            
            const checkAndInit = setInterval(function() {
                attempts++;
                
                if (typeof firebase !== 'undefined' && typeof firebaseConfig !== 'undefined') {
                    clearInterval(checkAndInit);
                    initializeFirebase();
                    // 초기화 후 init() 호출
                    setTimeout(function() {
                        init();
                    }, 200);
                } else if (attempts >= maxAttempts) {
                    clearInterval(checkAndInit);
                    console.error('Firebase SDK 또는 설정 파일 로드 실패');
                    // Firebase 없이도 기본 데이터 표시
                    init();
                }
            }, 100);
        }
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                waitForFirebaseAndInit();
            });
        } else {
            waitForFirebaseAndInit();
        }
        
        // 관리자 코드
        const ADMIN_CODE = 'admin123';
        
        // 권한 관리
        let isAdmin = false;
        let adminCode = '';

        // 티어 가중치 (높을수록 강함)
        const tierWeights = {
            'S': 7,
            'A+': 6,
            'A': 5,
            'B+': 4,
            'B': 3,
            'C': 2,
            'D': 1
        };

        // localStorage 키
        const ADMIN_CODE_KEY = 'jeotjaFcAdminCode';

        // 기본 선수 데이터
        const defaultPlayers = [
            { name: '정재오', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '강신재', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '장건호', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '김관영', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '김상욱', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '김승현', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '김태연', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '김동현', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '문용혁', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '문찬우', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '문태영', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '박찬영', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '박찬혁', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '배기정', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '하상우', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '김성호', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '신현우', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '옥준혁', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '우승훈', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '이도경', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '이신원', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '이준순', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '이창준', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '장재혁', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '정기헌', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '정우진', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '전근우', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '전은호', tier: 'B', win: 0, draw: 0, loss: 0 },
            { name: '박상윤', tier: 'B', win: 0, draw: 0, loss: 0 }
        ];

        // 투표 평균으로 티어 계산
        function calculateTierFromVotes(votes) {
            if (!votes || votes.length === 0) return 'B';
            
            // "모름" 투표는 제외하고 계산
            const validVotes = votes.filter(vote => vote.tier !== '모름');
            
            // 유효한 투표가 없으면 기본값 B 반환
            if (validVotes.length === 0) return 'B';
            
            const tierWeights = { 'S': 7, 'A+': 6, 'A': 5, 'B+': 4, 'B': 3, 'C': 2, 'D': 1 };
            const weightToTier = { 7: 'S', 6: 'A+', 5: 'A', 4: 'B+', 3: 'B', 2: 'C', 1: 'D' };
            
            const totalWeight = validVotes.reduce((sum, vote) => sum + (tierWeights[vote.tier] || 3), 0);
            const avgWeight = totalWeight / validVotes.length;
            
            // 가장 가까운 티어로 반올림
            const roundedWeight = Math.round(avgWeight);
            return weightToTier[roundedWeight] || 'B';
        }

        // 디바이스 ID 생성 (클라이언트 측)
        function getDeviceId() {
            // localStorage에 저장된 디바이스 ID 확인
            let deviceId = localStorage.getItem('deviceId');
            
            if (!deviceId) {
                // 새로운 디바이스 ID 생성 (User-Agent + 랜덤 값)
                const userAgent = navigator.userAgent || 'unknown';
                const screenInfo = `${screen.width}x${screen.height}`;
                const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                const combined = `${userAgent}-${screenInfo}-${timezone}-${Date.now()}-${Math.random()}`;
                
                // 간단한 해시 함수 (SHA-256 대신)
                let hash = 0;
                for (let i = 0; i < combined.length; i++) {
                    const char = combined.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // 32bit 정수로 변환
                }
                
                deviceId = Math.abs(hash).toString(36) + Date.now().toString(36);
                localStorage.setItem('deviceId', deviceId);
            }
            
            return deviceId;
        }
        
        // 선수 데이터 초기화
        let players = [];
        
        // 선택된 선수 추적 (선수 이름을 키로 사용)
        let selectedPlayers = new Set();
        
        // 투표 데이터
        let voteData = {};
        
        // 티어 표시 여부
        let showTier = true;
        
        // 현재 표시된 팀 정보 저장 (티어 숨기기 토글용)
        let currentTeamsData = null;
        let currentTeamSizes = null;
        
        // 페이지 로드 시 초기화
        async function init() {
            // 모달은 항상 표시 (사용자가 선택하도록)
            document.getElementById('adminModal').classList.add('active');
            
            // 저장된 관리자 코드가 있으면 입력 필드에 미리 채우기 (선택사항)
            const savedAdminCode = localStorage.getItem(ADMIN_CODE_KEY);
            if (savedAdminCode && savedAdminCode === ADMIN_CODE) {
                document.getElementById('adminCodeInput').value = savedAdminCode;
            }
            
            // Firebase 연결 확인
            if (!firebaseInitialized || !db) {
                console.warn('Firebase가 초기화되지 않았습니다. 기본 데이터를 표시합니다.');
                // Firebase가 없어도 기본 데이터는 표시
                players = defaultPlayers.map((p, idx) => ({ ...p, id: 'temp_' + idx }));
                sortPlayersByName();
                renderPlayers();
                renderTierTable();
                return;
            }
            
            // 선수 목록 로드 및 실시간 리스너 설정
            try {
                await loadPlayersFromFirebase();
                setupRealtimeListener();
            } catch (error) {
                console.error('데이터 로드 실패:', error);
                // 오류가 있어도 기본 데이터 표시
                players = defaultPlayers.map((p, idx) => ({ ...p, id: 'temp_' + idx }));
                sortPlayersByName();
                renderPlayers();
                renderTierTable();
            }
        }
        
        // 관리자로 입장
        async function enterAsAdmin() {
            const code = document.getElementById('adminCodeInput').value;
            if (!code) {
                alert('관리자 코드를 입력해주세요.');
                return;
            }
            
            if (code === ADMIN_CODE) {
                // Firebase 초기화 재시도 (최대 3초 대기)
                if (!firebaseInitialized) {
                    let attempts = 0;
                    while (!firebaseInitialized && attempts < 30) {
                        if (initializeFirebase()) {
                            break;
                        }
                        await new Promise(resolve => setTimeout(resolve, 100));
                        attempts++;
                    }
                    
                    if (!firebaseInitialized) {
                        console.error('Firebase 초기화 실패');
                        // Firebase 없이도 진행 (기본 데이터 사용)
                        alert('Firebase 연결에 실패했습니다. 오프라인 모드로 진행합니다.');
                    }
                }
                
                isAdmin = true;
                adminCode = code;
                localStorage.setItem(ADMIN_CODE_KEY, code);
                document.getElementById('adminModal').classList.remove('active');
                updateUIForPermission();
                
                // 데이터 로드
                if (db && firebaseInitialized) {
                    try {
                        await loadPlayersFromFirebase();
                        setupRealtimeListener();
                    } catch (error) {
                        console.error('데이터 로드 실패:', error);
                        // 오류가 있어도 기본 데이터 표시
                        players = defaultPlayers.map((p, idx) => ({ ...p, id: 'temp_' + idx }));
                        sortPlayersByName();
                        renderPlayers();
                        renderTierTable();
                        alert('데이터 로드에 실패했습니다. 오프라인 모드로 진행합니다.');
                    }
                } else {
                    console.warn('Firebase가 초기화되지 않았습니다. 기본 데이터를 사용합니다.');
                    // Firebase 없이도 기본 데이터 표시
                    players = defaultPlayers.map((p, idx) => ({ ...p, id: 'temp_' + idx }));
                    sortPlayersByName();
                    renderPlayers();
                    renderTierTable();
                }
            } else {
                alert('잘못된 관리자 코드입니다.');
            }
        }
        
        // 일반 사용자로 입장
        async function enterAsGuest() {
            isAdmin = false;
            adminCode = '';
            document.getElementById('adminModal').classList.remove('active');
            updateUIForPermission();
            
            // Firebase 초기화 재시도 (최대 3초 대기)
            if (!firebaseInitialized) {
                let attempts = 0;
                while (!firebaseInitialized && attempts < 30) {
                    if (initializeFirebase()) {
                        break;
                    }
                    await new Promise(resolve => setTimeout(resolve, 100));
                    attempts++;
                }
            }
            
            // 데이터 로드
            if (db && firebaseInitialized) {
                try {
                    await loadPlayersFromFirebase();
                    setupRealtimeListener();
                } catch (error) {
                    console.error('데이터 로드 실패:', error);
                    // 오류가 있어도 기본 데이터 표시
                    players = defaultPlayers.map((p, idx) => ({ ...p, id: 'temp_' + idx }));
                    sortPlayersByName();
                    renderPlayers();
                    renderTierTable();
                }
            } else {
                console.warn('Firebase가 초기화되지 않았습니다. 기본 데이터를 사용합니다.');
                // Firebase 없이도 기본 데이터 표시
                players = defaultPlayers.map((p, idx) => ({ ...p, id: 'temp_' + idx }));
                sortPlayersByName();
                renderPlayers();
                renderTierTable();
            }
        }
        
        // 권한에 따른 UI 업데이트
        function updateUIForPermission() {
            // 관리자 전용 버튼 활성화/비활성화
            const resetBtn = document.getElementById('resetBtn');
            resetBtn.disabled = !isAdmin;
            resetBtn.style.display = isAdmin ? 'inline-block' : 'none'; // 일반 사용자일 때 안보이게
            
            document.getElementById('addPlayerForm').style.display = isAdmin ? 'block' : 'none';
            
            // 티어 투표하기 버튼: 관리자일 때 안보이게
            const voteBtn = document.getElementById('voteBtn');
            if (voteBtn) {
                voteBtn.style.display = isAdmin ? 'none' : 'inline-block';
            }
            
            // 티어 투표 이력 보기 버튼: 관리자일 때만 보이게
            const voteHistoryBtn = document.getElementById('voteHistoryBtn');
            if (voteHistoryBtn) {
                voteHistoryBtn.style.display = isAdmin ? 'inline-block' : 'none';
            }
            
            // 선수 카드의 수정/삭제 버튼은 renderPlayers에서 처리
            // 권한 변경 시 선수 목록 다시 렌더링
            if (players.length > 0) {
                renderPlayers();
            }
        }
        
        // Firebase에서 선수 목록 로드
        async function loadPlayersFromFirebase() {
            console.log('loadPlayersFromFirebase 호출');
            console.log('db 상태:', db);
            console.log('firebaseInitialized:', firebaseInitialized);
            
            if (!db || typeof db === 'undefined') {
                console.error('❌ Firebase가 초기화되지 않았습니다.');
                // 임시 ID를 가진 기본 데이터 사용
                players = defaultPlayers.map((p, idx) => ({ ...p, id: 'temp_' + idx }));
                sortPlayersByName();
                renderPlayers();
                renderTierTable();
                return;
            }
            
            try {
                console.log('Firestore에서 선수 목록 조회 시도...');
                const playersRef = db.collection('players');
                const snapshot = await playersRef.get();
                console.log('선수 목록 조회 완료, 문서 수:', snapshot.size);
                
                if (snapshot.empty) {
                    console.log('데이터가 없음, 기본 선수 데이터 추가 시도...');
                    // 데이터가 없으면 기본 선수 데이터 추가
                    await initializeDefaultPlayers();
                    // 다시 로드
                    const newSnapshot = await playersRef.get();
                    players = newSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    console.log('기본 선수 데이터 추가 완료, 선수 수:', players.length);
                } else {
                    players = snapshot.docs.map(doc => {
                        const data = doc.data();
                        // win, draw, loss가 없는 경우 기본값 0으로 설정
                        return {
                            id: doc.id,
                            name: data.name,
                            tier: data.tier,
                            win: data.win !== undefined ? data.win : 0,
                            draw: data.draw !== undefined ? data.draw : 0,
                            loss: data.loss !== undefined ? data.loss : 0
                        };
                    });
                    console.log('선수 목록 로드 완료, 선수 수:', players.length);
                }
                
                // 투표 데이터로 티어 업데이트
                console.log('투표 데이터로 티어 업데이트 시도...');
                await updateTiersFromVotes();
                
                sortPlayersByName();
                renderPlayers();
                renderTierTable();
                console.log('✅ 선수 목록 로드 및 렌더링 완료');
            } catch (error) {
                console.error('❌ 선수 목록 로드 실패:', error);
                console.error('오류 상세:', error.message);
                console.error('오류 코드:', error.code);
                console.error('오류 스택:', error.stack);
                // 오류가 있어도 기본 데이터 표시
                players = defaultPlayers.map((p, idx) => ({ ...p, id: 'temp_' + idx }));
                sortPlayersByName();
                renderPlayers();
                renderTierTable();
            }
        }
        
        // 기본 선수 데이터 초기화
        async function initializeDefaultPlayers() {
            if (!db) {
                console.error('Firebase가 초기화되지 않았습니다.');
                return;
            }
            
            try {
                const batch = db.batch();
                defaultPlayers.forEach(player => {
                    const docRef = db.collection('players').doc();
                    // win, draw, loss가 없는 경우 기본값 0으로 설정
                    const playerData = {
                        name: player.name,
                        tier: player.tier,
                        win: player.win || 0,
                        draw: player.draw || 0,
                        loss: player.loss || 0
                    };
                    batch.set(docRef, playerData);
                });
                await batch.commit();
            } catch (error) {
                console.error('기본 선수 데이터 초기화 실패:', error);
                throw error;
            }
        }
        
        // 승률 계산 함수
        function calculateWinRate(player) {
            const win = player.win || 0;
            const draw = player.draw || 0;
            const loss = player.loss || 0;
            const total = win + draw + loss;
            
            if (total === 0) {
                return 0;
            }
            
            return ((win / total) * 100).toFixed(1);
        }
        
        // 실시간 리스너 설정 (다른 사용자의 변경사항 실시간 반영)
        // 실시간 리스너 (중복 방지)
        let playersListener = null;
        let isInitialLoad = true; // 초기 로드 여부
        
        function setupRealtimeListener() {
            if (!db) return;
            
            // 기존 리스너가 있으면 제거 (중복 방지)
            if (playersListener) {
                playersListener();
                playersListener = null;
            }
            
            // 초기 로드 플래그 리셋
            isInitialLoad = true;
            
            // 새 리스너 설정
            playersListener = db.collection('players').onSnapshot((snapshot) => {
                // 초기 로드 시에는 변경사항 처리하지 않음 (이미 loadPlayersFromFirebase에서 로드됨)
                if (isInitialLoad) {
                    isInitialLoad = false;
                    // 초기 로드 후에는 변경사항만 처리
                    return;
                }
                
                // 변경사항이 있을 때만 업데이트
                let hasChanges = false;
                
                snapshot.docChanges().forEach((change) => {
                    // 초기 로드가 아닌 경우에만 처리
                    if (change.type === 'added' || change.type === 'modified') {
                        hasChanges = true;
                        const data = change.doc.data();
                        const playerData = {
                            id: change.doc.id,
                            name: data.name,
                            tier: data.tier,
                            win: data.win !== undefined ? data.win : 0,
                            draw: data.draw !== undefined ? data.draw : 0,
                            loss: data.loss !== undefined ? data.loss : 0
                        };
                        const index = players.findIndex(p => p.id === change.doc.id);
                        if (index >= 0) {
                            players[index] = playerData;
                        } else {
                            players.push(playerData);
                        }
                    } else if (change.type === 'removed') {
                        hasChanges = true;
                        players = players.filter(p => p.id !== change.doc.id);
                    }
                });
                
                // 변경사항이 있을 때만 렌더링
                if (hasChanges) {
                    // 투표 데이터로 티어 업데이트
                    updateTiersFromVotes().then(() => {
                        sortPlayersByName();
                        renderPlayers();
                        renderTierTable();
                    });
                }
            }, (error) => {
                console.error('실시간 리스너 오류:', error);
            });
        }
        
        // Firebase에 선수 목록 저장
        async function savePlayersToFirebase() {
            if (!isAdmin) return;
            
            try {
                const batch = db.batch();
                
                // 기존 선수들 업데이트
                for (const player of players) {
                    if (player.id) {
                        const docRef = db.collection('players').doc(player.id);
                        const { id, ...playerData } = player;
                        batch.update(docRef, playerData);
                    }
                }
                
                await batch.commit();
            } catch (error) {
                console.error('선수 목록 저장 실패:', error);
                alert('저장에 실패했습니다.');
            }
        }
        
        // 투표 데이터로 티어 업데이트
        async function updateTiersFromVotes() {
            if (!db) return;
            
            try {
                const votesSnapshot = await db.collection('votes').get();
                const votes = votesSnapshot.docs.map(doc => doc.data());
                
                // 선수별로 투표 그룹화
                const votesByPlayer = {};
                votes.forEach(vote => {
                    if (!votesByPlayer[vote.playerName]) {
                        votesByPlayer[vote.playerName] = [];
                    }
                    votesByPlayer[vote.playerName].push(vote);
                });
                
                // 각 선수의 티어를 투표 평균으로 업데이트
                const batch = db.batch();
                let hasUpdates = false;
                for (const player of players) {
                    const playerVotes = votesByPlayer[player.name] || [];
                    if (playerVotes.length > 0) {
                        const calculatedTier = calculateTierFromVotes(playerVotes);
                        if (player.tier !== calculatedTier) {
                            player.tier = calculatedTier;
                            if (player.id) {
                                const docRef = db.collection('players').doc(player.id);
                                batch.update(docRef, { tier: calculatedTier });
                                hasUpdates = true;
                            }
                        }
                    }
                }
                
                if (hasUpdates) {
                    await batch.commit();
                }
            } catch (error) {
                console.error('티어 업데이트 실패:', error);
            }
        }

        // 한국어 이름 정렬 함수 (성 기준 가나다 순)
        function sortPlayersByName() {
            players.sort((a, b) => {
                // 첫 글자(성)를 기준으로 정렬
                return a.name.localeCompare(b.name, 'ko');
            });
        }

        // 선수 목록 렌더링
        function renderPlayers() {
            // 이름 기준으로 정렬
            sortPlayersByName();
            
            const grid = document.getElementById('playersGrid');
            grid.innerHTML = '';

            players.forEach((player, index) => {
                const card = document.createElement('div');
                card.className = 'player-card';
                card.style.cursor = 'pointer';
                const isSelected = selectedPlayers.has(player.name);
                
                // 카드 클릭 이벤트 추가
                card.onclick = function(e) {
                    // 체크박스나 삭제 버튼 클릭 시에는 기본 동작 유지
                    if (e.target.type === 'checkbox' || e.target.classList.contains('btn') || e.target.tagName === 'SELECT') {
                        return;
                    }
                    // 카드 클릭 시 체크박스 토글
                    const checkbox = card.querySelector('.player-checkbox');
                    checkbox.checked = !checkbox.checked;
                    togglePlayerSelection(player.name, checkbox.checked);
                };
                
                // 관리자만 수정/삭제 가능
                const tierSelectDisabled = isAdmin ? '' : 'disabled';
                const playerId = player.id || '';
                // 관리자이고 playerId가 있으면 삭제 버튼 표시
                const deleteButtonHtml = (isAdmin && playerId) 
                    ? `<button class="btn btn-danger delete-btn" onclick="event.stopPropagation(); deletePlayerById('${playerId}')">삭제</button>`
                    : '';
                
                const win = player.win || 0;
                const draw = player.draw || 0;
                const loss = player.loss || 0;
                const winRate = calculateWinRate(player);
                
                // 승/무/패 입력 필드 (관리자만 수정 가능)
                const recordInputDisabled = isAdmin ? '' : 'disabled';
                const recordInputStyle = isAdmin ? '' : 'background: #f0f0f0; cursor: not-allowed;';
                
                card.innerHTML = `
                    <div class="player-name">
                        <input type="checkbox" class="player-checkbox" 
                               ${isSelected ? 'checked' : ''} 
                               onchange="togglePlayerSelection('${player.name}', this.checked)"
                               onclick="event.stopPropagation()">
                        ${player.name}
                    </div>
                    <div class="player-fields">
                        <div class="field-group">
                            <label>티어</label>
                            <select onchange="updatePlayerById('${playerId}', 'tier', this.value)" onclick="event.stopPropagation()" ${tierSelectDisabled}>
                                <option value="S" ${player.tier === 'S' ? 'selected' : ''}>S</option>
                                <option value="A+" ${player.tier === 'A+' ? 'selected' : ''}>A+</option>
                                <option value="A" ${player.tier === 'A' ? 'selected' : ''}>A</option>
                                <option value="B+" ${player.tier === 'B+' ? 'selected' : ''}>B+</option>
                                <option value="B" ${player.tier === 'B' ? 'selected' : ''}>B</option>
                                <option value="C" ${player.tier === 'C' ? 'selected' : ''}>C</option>
                                <option value="D" ${player.tier === 'D' ? 'selected' : ''}>D</option>
                            </select>
                        </div>
                        <div class="field-group">
                            <label>승/무/패 (승률: ${winRate}%)</label>
                            <div style="display: flex; gap: 5px; align-items: center;">
                                <input type="number" min="0" value="${win}" 
                                       onchange="updatePlayerById('${playerId}', 'win', parseInt(this.value) || 0)" 
                                       onclick="event.stopPropagation()"
                                       ${recordInputDisabled}
                                       class="record-input"
                                       style="${recordInputStyle}"
                                       placeholder="승">
                                <span style="font-weight: 600;">/</span>
                                <input type="number" min="0" value="${draw}" 
                                       onchange="updatePlayerById('${playerId}', 'draw', parseInt(this.value) || 0)" 
                                       onclick="event.stopPropagation()"
                                       ${recordInputDisabled}
                                       class="record-input"
                                       style="${recordInputStyle}"
                                       placeholder="무">
                                <span style="font-weight: 600;">/</span>
                                <input type="number" min="0" value="${loss}" 
                                       onchange="updatePlayerById('${playerId}', 'loss', parseInt(this.value) || 0)" 
                                       onclick="event.stopPropagation()"
                                       ${recordInputDisabled}
                                       class="record-input"
                                       style="${recordInputStyle}"
                                       placeholder="패">
                            </div>
                        </div>
                        ${deleteButtonHtml}
                    </div>
                `;
                grid.appendChild(card);
            });
            
            // 티어표도 업데이트
            renderTierTable();
        }

        // 선수 선택 토글
        function togglePlayerSelection(playerName, isChecked) {
            if (isChecked) {
                selectedPlayers.add(playerName);
            } else {
                selectedPlayers.delete(playerName);
            }
        }

        // 전체 선택
        function selectAllPlayers() {
            players.forEach(player => {
                selectedPlayers.add(player.name);
            });
            renderPlayers();
        }

        // 전체 해제
        function deselectAllPlayers() {
            selectedPlayers.clear();
            renderPlayers();
        }

        // 초기값으로 되돌리기
        async function resetToDefault() {
            if (!isAdmin) {
                alert('관리자만 초기값으로 되돌릴 수 있습니다.');
                return;
            }
            
            if (!db) {
                alert('Firebase가 초기화되지 않았습니다.');
                return;
            }
            
            if (confirm('모든 선수 데이터를 초기 상태로 되돌리시겠습니까?\n(추가/수정/삭제한 모든 내용이 초기값으로 복원됩니다)')) {
                try {
                    // 기존 선수 모두 삭제
                    const playersSnapshot = await db.collection('players').get();
                    const batch1 = db.batch();
                    playersSnapshot.docs.forEach(doc => {
                        batch1.delete(doc.ref);
                    });
                    if (playersSnapshot.docs.length > 0) {
                        await batch1.commit();
                    }
                    
                    // 투표 데이터 삭제
                    const votesSnapshot = await db.collection('votes').get();
                    const batch2 = db.batch();
                    votesSnapshot.docs.forEach(doc => {
                        batch2.delete(doc.ref);
                    });
                    if (votesSnapshot.docs.length > 0) {
                        await batch2.commit();
                    }
                    
                    // 기본 선수 데이터 추가
                    await initializeDefaultPlayers();
                    
                    // 선택된 선수 목록 초기화
                    selectedPlayers.clear();
                    
                    // 선수 목록 다시 로드
                    await loadPlayersFromFirebase();
                    
                    alert('초기값으로 복원되었습니다.');
                } catch (error) {
                    console.error('초기화 실패:', error);
                    alert('초기화에 실패했습니다: ' + error.message);
                }
            }
        }
        
        // 투표 모달 열기
        async function openVoteModal() {
            if (!db) {
                alert('Firebase가 초기화되지 않았습니다. 투표 기능을 사용할 수 없습니다.');
                return;
            }
            
            if (players.length === 0) {
                alert('선수가 없습니다.');
                return;
            }
            
            // 투표 상태 확인
            const deviceId = getDeviceId();
            try {
                const votesSnapshot = await db.collection('votes')
                    .where('deviceId', '==', deviceId)
                    .get();
                
                if (!votesSnapshot.empty) {
                    if (!confirm('이미 투표하셨습니다. 다시 투표하시겠습니까?\n(기존 투표는 덮어씌워집니다)')) {
                        return;
                    }
                }
            } catch (error) {
                console.error('투표 상태 확인 실패:', error);
            }
            
            // 기존 투표 데이터 가져오기 (있으면 미리 채우기)
            const existingVotes = {};
            try {
                const existingVotesSnapshot = await db.collection('votes')
                    .where('deviceId', '==', deviceId)
                    .get();
                
                existingVotesSnapshot.docs.forEach(doc => {
                    const voteData = doc.data();
                    existingVotes[voteData.playerName] = voteData.tier;
                });
            } catch (error) {
                console.error('기존 투표 데이터 로드 실패:', error);
            }
            
            // 투표 UI 생성
            const voteContent = document.getElementById('voteContent');
            voteContent.innerHTML = '<div class="vote-grid" id="voteGrid"></div>';
            
            const voteGrid = document.getElementById('voteGrid');
            players.forEach(player => {
                // 기존 투표가 있으면 그 값을 사용, 없으면 기본값 B 사용 (다른 사람의 투표 결과가 아닌)
                const selectedTier = existingVotes[player.name] || 'B';
                
                const voteItem = document.createElement('div');
                voteItem.className = 'vote-item';
                voteItem.innerHTML = `
                    <span style="flex: 1; font-weight: 600;">${player.name}</span>
                    <select id="vote_${player.name}" class="vote-select">
                        <option value="S" ${selectedTier === 'S' ? 'selected' : ''}>S</option>
                        <option value="A+" ${selectedTier === 'A+' ? 'selected' : ''}>A+</option>
                        <option value="A" ${selectedTier === 'A' ? 'selected' : ''}>A</option>
                        <option value="B+" ${selectedTier === 'B+' ? 'selected' : ''}>B+</option>
                        <option value="B" ${selectedTier === 'B' ? 'selected' : ''}>B</option>
                        <option value="C" ${selectedTier === 'C' ? 'selected' : ''}>C</option>
                        <option value="D" ${selectedTier === 'D' ? 'selected' : ''}>D</option>
                        <option value="모름" ${selectedTier === '모름' ? 'selected' : ''}>모름</option>
                    </select>
                `;
                voteGrid.appendChild(voteItem);
            });
            
            document.getElementById('voteModal').classList.add('active');
            // 모달이 열릴 때 body 스크롤 막기
            document.body.style.overflow = 'hidden';
            
            // 모달 내부 스크롤 영역에 터치 이벤트 핸들러 추가 (모바일)
            const voteContentEl = document.getElementById('voteContent');
            let startY = 0;
            let isScrolling = false;
            
            voteContentEl.addEventListener('touchstart', function(e) {
                startY = e.touches[0].clientY;
                isScrolling = false;
            }, { passive: true });
            
            voteContentEl.addEventListener('touchmove', function(e) {
                const currentY = e.touches[0].clientY;
                const scrollTop = voteContentEl.scrollTop;
                const scrollHeight = voteContentEl.scrollHeight;
                const clientHeight = voteContentEl.clientHeight;
                
                // 스크롤 가능 여부 확인
                const isAtTop = scrollTop === 0;
                const isAtBottom = scrollTop + clientHeight >= scrollHeight - 1;
                const isScrollingUp = currentY > startY;
                const isScrollingDown = currentY < startY;
                
                // 스크롤이 끝에 도달했고, 그 방향으로 더 스크롤하려고 하면 배경 스크롤 방지
                if ((isAtTop && isScrollingUp) || (isAtBottom && isScrollingDown)) {
                    e.preventDefault();
                }
                
                isScrolling = true;
            }, { passive: false });
            
            voteContentEl.addEventListener('touchend', function(e) {
                isScrolling = false;
            }, { passive: true });
        }
        
        // 투표 모달 닫기
        function closeVoteModal() {
            document.getElementById('voteModal').classList.remove('active');
            // 모달이 닫힐 때 body 스크롤 복원
            document.body.style.overflow = '';
        }
        
        // 투표 제출
        async function submitVote() {
            const deviceId = getDeviceId();
            const votes = [];
            
            players.forEach(player => {
                const select = document.getElementById(`vote_${player.name}`);
                if (select) {
                    votes.push({
                        playerName: player.name,
                        tier: select.value
                    });
                }
            });
            
            try {
                // 기존 투표 삭제 (이 디바이스의 모든 투표)
                const existingVotesSnapshot = await db.collection('votes')
                    .where('deviceId', '==', deviceId)
                    .get();
                
                const batch = db.batch();
                existingVotesSnapshot.docs.forEach(doc => {
                    batch.delete(doc.ref);
                });
                
                // 새 투표 추가
                const timestamp = firebase.firestore.FieldValue.serverTimestamp();
                votes.forEach(({ playerName, tier }) => {
                    const voteRef = db.collection('votes').doc();
                    batch.set(voteRef, {
                        playerName,
                        tier,
                        deviceId,
                        timestamp
                    });
                });
                
                await batch.commit();
                
                // 티어 업데이트 (투표 평균 계산)
                await updateTiersFromVotes();
                
                closeVoteModal();
                alert('투표가 완료되었습니다.');
            } catch (error) {
                console.error('투표 제출 실패:', error);
                alert('투표 제출에 실패했습니다.');
            }
        }

        // 투표 이력 모달 열기 (관리자 전용)
        async function openVoteHistoryModal() {
            if (!db) {
                alert('Firebase가 초기화되지 않았습니다.');
                return;
            }
            
            if (!isAdmin) {
                alert('관리자만 접근할 수 있습니다.');
                return;
            }
            
            try {
                // 모든 투표 데이터 가져오기
                let votesSnapshot;
                try {
                    votesSnapshot = await db.collection('votes')
                        .orderBy('timestamp', 'desc')
                        .get();
                } catch (error) {
                    // timestamp 인덱스가 없거나 timestamp 필드가 없으면 전체 가져오기
                    console.warn('timestamp로 정렬 실패, 전체 데이터 가져오기:', error);
                    votesSnapshot = await db.collection('votes').get();
                }
                
                if (votesSnapshot.empty) {
                    document.getElementById('voteHistoryContent').innerHTML = 
                        '<div style="text-align: center; padding: 40px; color: #999;">아직 투표가 없습니다.</div>';
                    document.getElementById('voteHistoryModal').classList.add('active');
                    document.body.style.overflow = 'hidden';
                    return;
                }
                
                const allVotes = votesSnapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data()
                }));
                
                // 디바이스별로 그룹화
                const votesByDevice = {};
                allVotes.forEach(vote => {
                    if (!votesByDevice[vote.deviceId]) {
                        votesByDevice[vote.deviceId] = [];
                    }
                    votesByDevice[vote.deviceId].push(vote);
                });
                
                // 총 투표 수 표시
                const totalVoteCount = Object.keys(votesByDevice).length;
                document.getElementById('totalVoteCount').textContent = totalVoteCount;
                
                // 테이블 생성
                const tableContainer = document.getElementById('voteHistoryTable');
                tableContainer.innerHTML = '';
                
                // 선수 목록 가져오기 (정렬)
                const sortedPlayers = [...players].sort((a, b) => a.name.localeCompare(b.name, 'ko'));
                
                // 테이블 생성
                const table = document.createElement('table');
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                table.style.marginTop = '20px';
                table.style.fontSize = '0.9em';
                
                // 헤더 행
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                headerRow.style.backgroundColor = '#667eea';
                headerRow.style.color = 'white';
                
                const playerHeader = document.createElement('th');
                playerHeader.textContent = '선수 이름';
                playerHeader.style.padding = '12px';
                playerHeader.style.textAlign = 'left';
                playerHeader.style.border = '1px solid #ddd';
                headerRow.appendChild(playerHeader);
                
                // 각 디바이스별 헤더 추가
                const deviceIds = Object.keys(votesByDevice);
                deviceIds.forEach((deviceId, index) => {
                    const deviceHeader = document.createElement('th');
                    deviceHeader.textContent = `투표 ${index + 1}`;
                    deviceHeader.style.padding = '12px';
                    deviceHeader.style.textAlign = 'center';
                    deviceHeader.style.border = '1px solid #ddd';
                    deviceHeader.style.minWidth = '80px';
                    headerRow.appendChild(deviceHeader);
                });
                
                thead.appendChild(headerRow);
                table.appendChild(thead);
                
                // 본문
                const tbody = document.createElement('tbody');
                
                sortedPlayers.forEach((player, playerIndex) => {
                    const row = document.createElement('tr');
                    row.style.backgroundColor = playerIndex % 2 === 0 ? '#ffffff' : '#f8f9fa';
                    
                    // 선수 이름 셀
                    const nameCell = document.createElement('td');
                    nameCell.textContent = player.name;
                    nameCell.style.padding = '10px 12px';
                    nameCell.style.border = '1px solid #ddd';
                    nameCell.style.fontWeight = '600';
                    row.appendChild(nameCell);
                    
                    // 각 디바이스별 투표 셀
                    deviceIds.forEach(deviceId => {
                        const voteCell = document.createElement('td');
                        voteCell.style.padding = '10px';
                        voteCell.style.border = '1px solid #ddd';
                        voteCell.style.textAlign = 'center';
                        
                        const deviceVotes = votesByDevice[deviceId];
                        const playerVote = deviceVotes.find(v => v.playerName === player.name);
                        
                        if (playerVote) {
                            if (playerVote.tier === '모름') {
                                voteCell.textContent = '모름';
                                voteCell.style.color = '#999';
                                voteCell.style.fontStyle = 'italic';
                            } else {
                                const tierBadge = document.createElement('span');
                                tierBadge.className = `tier-badge tier-${playerVote.tier.replace('+', 'plus')}`;
                                tierBadge.textContent = playerVote.tier;
                                tierBadge.style.display = 'inline-block';
                                voteCell.appendChild(tierBadge);
                            }
                        } else {
                            voteCell.textContent = '-';
                            voteCell.style.color = '#ccc';
                        }
                        
                        row.appendChild(voteCell);
                    });
                    
                    tbody.appendChild(row);
                });
                
                table.appendChild(tbody);
                tableContainer.appendChild(table);
                
                // 모달 표시
                document.getElementById('voteHistoryModal').classList.add('active');
                document.body.style.overflow = 'hidden';
                
            } catch (error) {
                console.error('투표 이력 로드 실패:', error);
                alert('투표 이력을 불러오는데 실패했습니다: ' + error.message);
            }
        }
        
        // 투표 이력 모달 닫기
        function closeVoteHistoryModal() {
            document.getElementById('voteHistoryModal').classList.remove('active');
            document.body.style.overflow = '';
        }

        // 티어표 렌더링
        function renderTierTable() {
            const tierList = document.getElementById('tierList');
            tierList.innerHTML = '';

            // 티어 순서
            const tierOrder = ['S', 'A+', 'A', 'B+', 'B', 'C', 'D'];
            
            tierOrder.forEach(tier => {
                const tierPlayers = players.filter(p => p.tier === tier);
                
                const tierItem = document.createElement('div');
                tierItem.className = 'tier-item';
                
                tierItem.innerHTML = `
                    <div class="tier-item-header">
                        <span class="tier-badge tier-${tier.replace('+', 'plus')} tier-item-label">${tier}</span>
                        <span class="tier-item-count">${tierPlayers.length}명</span>
                    </div>
                    <div class="tier-item-players">
                        ${tierPlayers.length > 0 
                            ? tierPlayers.map(p => `<span class="tier-player-name">${p.name}</span>`).join('')
                            : '<span class="tier-player-name" style="color: #999;">선수 없음</span>'
                        }
                    </div>
                `;
                tierList.appendChild(tierItem);
            });
        }

        // 선수 추가
        async function addPlayer() {
            if (!isAdmin) {
                alert('관리자만 선수를 추가할 수 있습니다.');
                return;
            }
            
            if (!db || typeof db === 'undefined') {
                alert('Firebase가 초기화되지 않았습니다. 페이지를 새로고침해주세요.');
                console.error('db 상태:', db);
                return;
            }
            
            const name = document.getElementById('newPlayerName').value.trim();
            const tier = document.getElementById('newPlayerTier').value;

            if (!name) {
                alert('이름을 입력해주세요.');
                return;
            }

            if (players.some(p => p.name === name)) {
                alert('이미 존재하는 선수입니다.');
                return;
            }

            try {
                // Firebase에 추가만 하고, 로컬 배열에는 추가하지 않음
                // 실시간 리스너가 자동으로 추가해줄 것임
                await db.collection('players').add({ 
                    name, 
                    tier,
                    win: 0,
                    draw: 0,
                    loss: 0
                });
                
                // 새로 추가된 선수는 체크 해제 상태 (자동 선택 안 함)
                document.getElementById('newPlayerName').value = '';
                // renderPlayers()는 실시간 리스너가 자동으로 호출함
            } catch (error) {
                console.error('선수 추가 실패:', error);
                alert('선수 추가에 실패했습니다: ' + error.message);
            }
        }

        // 선수 정보 업데이트 (ID로)
        async function updatePlayerById(playerId, field, value) {
            if (!isAdmin) {
                alert('관리자만 선수 정보를 수정할 수 있습니다.');
                return;
            }
            
            if (!db || typeof db === 'undefined') {
                alert('Firebase가 초기화되지 않았습니다. 페이지를 새로고침해주세요.');
                console.error('db 상태:', db);
                return;
            }
            
            if (!playerId) {
                alert('선수 정보를 찾을 수 없습니다.');
                return;
            }
            
            const player = players.find(p => p.id === playerId);
            if (!player) {
                alert('선수 정보를 찾을 수 없습니다.');
                return;
            }
            
            try {
                // Firebase 업데이트
                await db.collection('players').doc(playerId).update({ [field]: value });
                player[field] = value;
                renderTierTable(); // 티어표 업데이트
            } catch (error) {
                console.error('선수 정보 업데이트 실패:', error);
                alert('업데이트에 실패했습니다: ' + error.message);
            }
        }

        // 선수 삭제 (ID로)
        async function deletePlayerById(playerId) {
            if (!isAdmin) {
                alert('관리자만 선수를 삭제할 수 있습니다.');
                return;
            }
            
            if (!db) {
                alert('Firebase가 초기화되지 않았습니다.');
                return;
            }
            
            if (!playerId) {
                alert('선수 정보를 찾을 수 없습니다.');
                return;
            }
            
            const player = players.find(p => p.id === playerId);
            if (!player) {
                alert('선수 정보를 찾을 수 없습니다.');
                return;
            }
            
            const playerName = player.name;
            if (confirm(`${playerName} 선수를 삭제하시겠습니까?`)) {
                try {
                    // 선택 목록에서도 제거
                    selectedPlayers.delete(playerName);
                    
                    // Firebase에서 삭제만 하고, 로컬 배열 수정은 하지 않음
                    // 실시간 리스너가 자동으로 제거해줄 것임
                    await db.collection('players').doc(playerId).delete();
                    
                    // 투표 데이터도 삭제
                    const votesSnapshot = await db.collection('votes')
                        .where('playerName', '==', playerName)
                        .get();
                    
                    if (!votesSnapshot.empty) {
                        const batch = db.batch();
                        votesSnapshot.docs.forEach(doc => {
                            batch.delete(doc.ref);
                        });
                        await batch.commit();
                    }
                    
                    // renderPlayers()는 실시간 리스너가 자동으로 호출함
                } catch (error) {
                    console.error('선수 삭제 실패:', error);
                    alert('삭제에 실패했습니다: ' + error.message);
                }
            }
        }

        // 풋살팀 구성 규칙
        function getFutsalTeamSizes(totalPlayers) {
            const rules = {
                12: [6, 6],
                13: [7, 6],
                14: [7, 7],
                15: [5, 5, 5],
                16: [8, 8],
                17: [6, 6, 5],
                18: [6, 6, 6],
                19: [7, 6, 6],
                20: [7, 7, 6],
                21: [7, 7, 7],
                22: [6, 6, 5, 5],
                23: [6, 6, 6, 5],
                24: [6, 6, 6, 6],
                25: [7, 6, 6, 6],
                26: [7, 7, 6, 6],
                27: [7, 7, 7, 6],
                28: [7, 7, 7, 7]
            };
            
            if (rules[totalPlayers]) {
                return rules[totalPlayers];
            }
            
            // 10-11명인 경우 기본 처리 (2팀)
            if (totalPlayers < 12) {
                const teamSize = Math.floor(totalPlayers / 2);
                const remainder = totalPlayers % 2;
                if (remainder === 0) {
                    return [teamSize, teamSize];
                } else {
                    return [teamSize + 1, teamSize];
                }
            }
            
            return null;
        }

        // 축구팀 구성 규칙 (2팀으로 나누기)
        function getSoccerTeamSizes(totalPlayers) {
            const teamSize = Math.floor(totalPlayers / 2);
            const remainder = totalPlayers % 2;
            if (remainder === 0) {
                return [teamSize, teamSize];
            } else {
                return [teamSize + 1, teamSize];
            }
        }

        // 풋살팀 구성 생성
        function generateFutsalTeams() {
            // 선택된 선수들만 필터링
            const selectedPlayersList = players.filter(p => selectedPlayers.has(p.name));
            const totalPlayers = selectedPlayersList.length;
            
            if (totalPlayers < 10) {
                alert('최소 10명의 선수를 선택해주세요.');
                return;
            }

            // 29명 이상일 때 경고
            if (totalPlayers >= 29) {
                alert('그냥 축구를 하세요');
                return;
            }

            // 총 인원에 따른 팀 크기 결정
            const teamSizes = getFutsalTeamSizes(totalPlayers);
            
            if (!teamSizes) {
                alert('풋살팀 구성이 불가능한 인원 수입니다.');
                return;
            }
            
            // 선택된 선수들을 매번 랜덤하게 섞기 (새로운 팀 구성을 위해)
            const shuffledList = [...selectedPlayersList].sort(() => Math.random() - 0.5);

            // 최적 팀 찾기 (최대 200번 시도, 매번 새로운 랜덤 시드)
            let bestTeams = null;
            let bestDiff = Infinity;

            for (let attempt = 0; attempt < 200; attempt++) {
                // 매 시도마다 선수 목록을 다시 섞기
                const reShuffledList = [...shuffledList].sort(() => Math.random() - 0.5);
                
                const teams = createBalancedTeams(teamSizes, reShuffledList);
                if (teams) {
                    const diff = calculateTeamDifference(teams);
                    if (diff < bestDiff) {
                        bestDiff = diff;
                        bestTeams = teams;
                        // 완벽한 밸런스면 중단
                        if (diff === 0) break;
                    }
                }
            }

            if (!bestTeams) {
                alert('팀 구성을 실패했습니다. 선수 수를 확인해주세요.');
                return;
            }

            renderTeams(bestTeams, teamSizes);
        }

        // 축구팀 구성 생성
        function generateSoccerTeams() {
            // 선택된 선수들만 필터링
            const selectedPlayersList = players.filter(p => selectedPlayers.has(p.name));
            const totalPlayers = selectedPlayersList.length;
            
            if (totalPlayers < 2) {
                alert('최소 2명의 선수를 선택해주세요.');
                return;
            }

            // 총 인원에 따른 팀 크기 결정 (2팀으로 나누기)
            const teamSizes = getSoccerTeamSizes(totalPlayers);
            
            // 선택된 선수들을 매번 랜덤하게 섞기 (새로운 팀 구성을 위해)
            const shuffledList = [...selectedPlayersList].sort(() => Math.random() - 0.5);

            // 최적 팀 찾기 (최대 200번 시도, 매번 새로운 랜덤 시드)
            let bestTeams = null;
            let bestDiff = Infinity;

            for (let attempt = 0; attempt < 200; attempt++) {
                // 매 시도마다 선수 목록을 다시 섞기
                const reShuffledList = [...shuffledList].sort(() => Math.random() - 0.5);
                
                const teams = createBalancedTeams(teamSizes, reShuffledList);
                if (teams) {
                    const diff = calculateTeamDifference(teams);
                    if (diff < bestDiff) {
                        bestDiff = diff;
                        bestTeams = teams;
                        // 완벽한 밸런스면 중단
                        if (diff === 0) break;
                    }
                }
            }

            if (!bestTeams) {
                alert('팀 구성을 실패했습니다. 선수 수를 확인해주세요.');
                return;
            }

            renderTeams(bestTeams, teamSizes);
        }

        // 밸런스 있는 팀 생성
        function createBalancedTeams(teamSizes, playerList) {
            const numTeams = teamSizes.length;
            const teams = Array(numTeams).fill(null).map(() => []);
            const used = new Set();
            
            // 티어별로 선수 분류
            const tierOrder = ['S', 'A+', 'A', 'B+', 'B', 'C', 'D'];
            
            // 티어별로 선수 분류
            function groupByTier(playerList) {
                const grouped = {};
                tierOrder.forEach(tier => {
                    grouped[tier] = playerList.filter(p => p.tier === tier && !used.has(p.name));
                });
                return grouped;
            }

            // 각 팀에 선수 배정 (티어 균등 분배 고려)
            for (let teamIdx = 0; teamIdx < numTeams; teamIdx++) {
                const teamSize = teamSizes[teamIdx];
                
                while (teams[teamIdx].length < teamSize) {
                    const playersByTier = groupByTier(playerList);
                    let assigned = false;
                    
                    // 티어 순서대로 라운드 로빈 방식으로 배정
                    for (const tier of tierOrder) {
                        const availablePlayers = playersByTier[tier];
                        if (availablePlayers.length > 0) {
                            const player = availablePlayers[0];
                            teams[teamIdx].push(player);
                            used.add(player.name);
                            assigned = true;
                            break;
                        }
                    }
                    
                    // 모든 티어에서 선수를 찾지 못한 경우 (이론적으로는 발생하지 않아야 함)
                    if (!assigned) {
                        // 남은 선수 중 아무나 배정
                        const remainingPlayer = playerList.find(p => !used.has(p.name));
                        if (remainingPlayer) {
                            teams[teamIdx].push(remainingPlayer);
                            used.add(remainingPlayer.name);
                        } else {
                            return null; // 선수가 부족함
                        }
                    }
                }
            }

            // 팀 크기 확인
            for (let i = 0; i < numTeams; i++) {
                if (teams[i].length !== teamSizes[i]) {
                    return null;
                }
            }

            // 티어 밸런스 최적화
            optimizeTierBalance(teams);

            return teams;
        }

        // 티어별 분배 개선 (인원당 평균도 고려)
        function improveTierDistribution(teams) {
            const criticalTiers = ['S', 'A+', 'D'];
            const tierOrder = ['S', 'A+', 'A', 'B+', 'B', 'C', 'D'];
            
            function getTeamTierAverage(team) {
                if (team.length === 0) return 0;
                const sum = team.reduce((sum, p) => sum + tierWeights[p.tier], 0);
                return sum / team.length;
            }
            
            function getAverageVariance(teams) {
                const averages = teams.map(team => getTeamTierAverage(team));
                const avg = averages.reduce((a, b) => a + b, 0) / averages.length;
                return averages.reduce((sum, s) => sum + Math.pow(s - avg, 2), 0) / averages.length;
            }
            
            for (let iteration = 0; iteration < 200; iteration++) {
                let improved = false;
                const currentAvgVariance = getAverageVariance(teams);
                
                // 각 티어별로 확인
                tierOrder.forEach(tier => {
                    const tierCounts = teams.map(team => 
                        team.filter(p => p.tier === tier).length
                    );
                    const maxCount = Math.max(...tierCounts);
                    const minCount = Math.min(...tierCounts);
                    
                    // 분배가 불균형하면 개선 시도
                    if (maxCount - minCount > 1 || (criticalTiers.includes(tier) && maxCount >= 2)) {
                        // 가장 많은 팀과 가장 적은 팀 찾기
                        const maxTeamIdx = tierCounts.indexOf(maxCount);
                        const minTeamIdx = tierCounts.indexOf(minCount);
                        
                        // 해당 티어 선수를 찾아서 교체 시도
                        const maxTeam = teams[maxTeamIdx];
                        const minTeam = teams[minTeamIdx];
                        
                        // 같은 티어가 아닌 선수와 교체
                        for (let i = 0; i < maxTeam.length; i++) {
                            if (maxTeam[i].tier === tier) {
                                for (let j = 0; j < minTeam.length; j++) {
                                    if (minTeam[j].tier !== tier) {
                                        // 교체 시도
                                        const temp = maxTeam[i];
                                        maxTeam[i] = minTeam[j];
                                        minTeam[j] = temp;
                                        
                                        // 인원당 평균 밸런스 개선 확인
                                        const newAvgVariance = getAverageVariance(teams);
                                        
                                        // 티어 분배 개선 확인
                                        const newTierCounts = teams.map(team => 
                                            team.filter(p => p.tier === tier).length
                                        );
                                        const newMaxCount = Math.max(...newTierCounts);
                                        const newMinCount = Math.min(...newTierCounts);
                                        
                                        // 인원당 평균 밸런스가 개선되거나, 티어 분배가 개선되고 인원당 평균이 나빠지지 않으면 수용
                                        const tierDistributionImproved = (newMaxCount - newMinCount < maxCount - minCount);
                                        const avgBalanceImproved = (newAvgVariance < currentAvgVariance);
                                        
                                        if (avgBalanceImproved || (tierDistributionImproved && newAvgVariance <= currentAvgVariance * 1.1)) {
                                            improved = true;
                                            break;
                                        } else {
                                            // 되돌리기
                                            minTeam[j] = maxTeam[i];
                                            maxTeam[i] = temp;
                                        }
                                    }
                                }
                                if (improved) break;
                            }
                        }
                    }
                });
                
                if (!improved) break;
            }
        }

        // 티어 밸런스 최적화
        function optimizeTierBalance(teams) {
            function getTeamTierSum(team) {
                return team.reduce((sum, p) => sum + tierWeights[p.tier], 0);
            }

            function getTeamTierAverage(team) {
                if (team.length === 0) return 0;
                return getTeamTierSum(team) / team.length;
            }

            function getTeamVariance(teams) {
                // 인원당 평균 티어를 기준으로 분산 계산
                const averages = teams.map(team => getTeamTierAverage(team));
                const avg = averages.reduce((a, b) => a + b, 0) / averages.length;
                const variance = averages.reduce((sum, s) => sum + Math.pow(s - avg, 2), 0) / averages.length;
                return variance;
            }

            // 먼저 티어별 분배 개선 (S, A+, D가 한 팀에 몰리지 않도록, 하지만 인원당 평균도 고려)
            improveTierDistribution(teams);

            // 여러 번 시도하여 전체 티어 합 밸런스 개선 (인원당 평균 우선)
            for (let iteration = 0; iteration < 200; iteration++) {
                const currentScore = calculateTeamDifference(teams);
                
                // 모든 팀 쌍에 대해 교체 시도
                let improved = false;
                
                for (let i = 0; i < teams.length; i++) {
                    for (let j = i + 1; j < teams.length; j++) {
                        const team1 = teams[i];
                        const team2 = teams[j];
                        
                        // 모든 선수 교체 시도
                        for (const p1 of team1) {
                            for (const p2 of team2) {
                                if (p1.tier !== p2.tier) {
                                    // 교체 시도
                                    const idx1 = team1.indexOf(p1);
                                    const idx2 = team2.indexOf(p2);
                                    team1[idx1] = p2;
                                    team2[idx2] = p1;
                                    
                                    const newScore = calculateTeamDifference(teams);
                                    if (newScore < currentScore) {
                                        improved = true;
                                        break;
                                    } else {
                                        // 되돌리기
                                        team1[idx1] = p1;
                                        team2[idx2] = p2;
                                    }
                                }
                            }
                            if (improved) break;
                        }
                        
                        if (improved) break;
                    }
                    if (improved) break;
                }
                
                if (!improved) break;
            }
        }

        // 티어별 분배 점수 계산 (낮을수록 좋음, 인원당 평균 밸런스 우선)
        function calculateTierDistributionScore(teams) {
            const tierOrder = ['S', 'A+', 'A', 'B+', 'B', 'C', 'D'];
            const criticalTiers = ['S', 'A+', 'D']; // 한 팀에 몰리면 안 되는 티어
            let score = 0;
            
            // 각 티어별로 팀 간 분배 확인
            tierOrder.forEach(tier => {
                const tierCounts = teams.map(team => 
                    team.filter(p => p.tier === tier).length
                );
                
                // 팀 간 분배의 분산 계산
                const avg = tierCounts.reduce((a, b) => a + b, 0) / tierCounts.length;
                const variance = tierCounts.reduce((sum, c) => sum + Math.pow(c - avg, 2), 0) / tierCounts.length;
                score += variance * 5; // 티어 분배 불균형 페널티 (기존 10에서 5로 감소)
                
                // S, A+, D 티어는 한 팀에 몰리면 큰 페널티 (하지만 인원당 평균 밸런스가 우선)
                if (criticalTiers.includes(tier)) {
                    const maxCount = Math.max(...tierCounts);
                    const minCount = Math.min(...tierCounts);
                    if (maxCount - minCount > 1) {
                        score += (maxCount - minCount - 1) * 50; // 큰 페널티 (기존 100에서 50으로 감소)
                    }
                    // 한 팀에 2명 이상 몰리면 추가 페널티
                    if (maxCount >= 2) {
                        score += (maxCount - 1) * 25; // 추가 페널티 (기존 50에서 25로 감소)
                    }
                }
            });
            
            return score;
        }

        // 팀 간 티어 차이 계산 (인원당 평균 기준)
        function calculateTeamDifference(teams) {
            // 인원당 평균 티어를 계산
            const averages = teams.map(team => {
                const sum = team.reduce((sum, p) => sum + tierWeights[p.tier], 0);
                return team.length > 0 ? sum / team.length : 0;
            });
            
            // 평균의 분산 계산
            const avg = averages.reduce((a, b) => a + b, 0) / averages.length;
            const variance = averages.reduce((sum, s) => sum + Math.pow(s - avg, 2), 0) / averages.length;
            
            // 티어 분배 점수 추가
            const tierDistributionScore = calculateTierDistributionScore(teams);
            
            return variance + tierDistributionScore;
        }

        // 티어 표시/숨기기 토글
        function toggleTierVisibility() {
            showTier = !document.getElementById('hideTierCheckbox').checked;
            // 현재 표시된 팀이 있으면 다시 렌더링
            if (currentTeamsData && currentTeamSizes) {
                renderTeams(currentTeamsData, currentTeamSizes);
            }
        }
        
        // 팀 렌더링
        function renderTeams(teams, teamSizes) {
            // 현재 팀 정보 저장 (티어 숨기기 토글용)
            currentTeamsData = teams;
            currentTeamSizes = teamSizes;
            
            const container = document.getElementById('teamsContainer');
            container.innerHTML = '';

            teams.forEach((team, index) => {
                const teamDiv = document.createElement('div');
                teamDiv.className = 'team';
                
                // 티어 순으로 정렬
                const sortedTeam = [...team].sort((a, b) => {
                    const tierOrder = ['S', 'A+', 'A', 'B+', 'B', 'C', 'D'];
                    const aIndex = tierOrder.indexOf(a.tier);
                    const bIndex = tierOrder.indexOf(b.tier);
                    return aIndex - bIndex;
                });
                
                const tierSum = sortedTeam.reduce((sum, p) => sum + tierWeights[p.tier], 0);
                const tierAverage = team.length > 0 ? (tierSum / team.length).toFixed(2) : 0;

                teamDiv.innerHTML = `
                    <div class="team-title">팀 ${index + 1} (${teamSizes[index]}명)</div>
                    <div class="team-stats">
                        <div>티어 합: ${tierSum}</div>
                        <div>인원당 평균: ${tierAverage}</div>
                    </div>
                    <ul class="team-players">
                        ${sortedTeam.map(player => `
                            <li class="team-player">
                                <div class="player-info">
                                    <div>${player.name}${showTier ? ` <span class="tier-badge tier-${player.tier.replace('+', 'plus')}">${player.tier}</span>` : ''}</div>
                                </div>
                            </li>
                        `).join('')}
                    </ul>
                `;
                container.appendChild(teamDiv);
            });
        }

        // 초기 렌더링
        init();
    </script>
</body>
</html>
